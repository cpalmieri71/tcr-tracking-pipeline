#!/usr/bin/env python3
"""
02_extract_plot_clones.py
=========================

Extract and visualize clonotype frequency trajectories from simulation or pipeline output files.

Overview
--------
This script reads one or more long-format trajectory files (typically generated by
the noise/QC/denoising pipeline, e.g. `trajectories_long_min2.csv`) and performs:

  • normalization of clonotype amino-acid sequences,
  • conversion to linear frequency (from either `freq` or `log_freq`),
  • selection of a target clonotype and a specified number of non-target 
    clonotypes that are present in all time points,
  • generation of combined trajectory tables across all inputs,
  • visualization of frequency vs time for selected clonotypes.

The script supports individual file paths or directories as input, and
produces both CSV outputs and a combined frequency-over-time plot.

Usage examples
--------------
1) Basic usage with a single trajectory file:
   python 02_extract_plot_clones.py \
       --input trajectories_long_min2.csv \
       --outdir results/

2) Multiple files (list all files or mix files and directories):
   python 02_extract_plot_clones.py \
       --input file1.csv file2.csv \
       --outdir results/

3) Input directory (searches for files matching "trajectories_long_min*.csv"):
   python 02_extract_plot_clones.py \
       --input ./sim_outputs/ \
       --outdir results/

4) Select only non-target clones within a linear frequency interval:
   python 02_extract_plot_clones.py \
       --input ./sim_outputs/ \
       --outdir results/ \
       --freq-min 1e-6 --freq-max 1e-4

5) Server execution without GUI display:
   python 02_extract_plot_clones.py \
       --input ./sim_outputs/ \
       --outdir results/ \
       --no-show

Input Requirements
------------------
Input trajectory files must contain at least these columns:
  - `aaSeqCDR3`: clonotype amino-acid sequence
  - `time`: numeric time point
  - `observable`: boolean-like indicator (true/false, 1/0, yes/no)
and at least one of:
  - `freq`: linear frequency
  - `log_freq`: log10 frequency, converted to linear internally

Outputs
-------
The script writes to the specified output directory:
  - `selected_clones_by_min_k.csv`
  - `multi_clones_extracted_trajectories.csv`
  - `multi_clones_observability_by_min_k.csv`
  - `multi_clones_frequency_vs_time.png`

These outputs include the full selected clonotype trajectories, a summary
of observability by time point, and a combined frequency-over-time plot.

Notes
-----
• The script attempts to parse a numeric “min_k” identifier from input file
  names based on the pattern `_min<digits>`. If that pattern is absent,
  `min_k` defaults to -1 to allow processing.
• Target clonotype plotting emphasizes the target sequence (thicker line and opacity).
"""


import re
import glob
from pathlib import Path
import argparse
from typing import Optional, List

import pandas as pd
import matplotlib.pyplot as plt

DEFAULT_TARGET = "CASSFSTCSANYGYTF"


def extract_min_from_filename(path: Path) -> int:
    """
    Extract min_k from a filename using the pattern "_min<digits>".

    Examples accepted:
      - trajectories_long_min2.csv
      - anything_min10_anything.csv

    Returns
    -------
    int
        The extracted integer (e.g., 2, 10). If the pattern is not found, returns -1
        so the script does not crash and you can still process/plot the file.
    """
    m = re.search(r"_min(\d+)", path.name)
    if not m:
        return -1
    return int(m.group(1))


def as_bool_series(s: pd.Series) -> pd.Series:
    """
    Convert a pandas Series to boolean values.

    Accepts typical boolean-like strings/numbers:
      - true/t/1/yes/y  -> True
      - everything else -> False

    Parameters
    ----------
    s : pd.Series
        Input series.

    Returns
    -------
    pd.Series (bool)
        Boolean series.
    """
    if s.dtype == bool:
        return s
    ss = s.astype(str).str.strip().str.lower()
    return ss.isin(["true", "t", "1", "yes", "y"])


def collect_input_files(inputs: List[str]) -> List[Path]:
    """
    Collect input files from a list of filesystem paths.

    Each element of `inputs` can be:
      - a single file path
      - a directory path (the script searches within it for trajectories_long_min*.csv,
        and falls back to trajectories_long_min* if no .csv matches are found)

    Parameters
    ----------
    inputs : List[str]
        List of file and/or directory paths.

    Returns
    -------
    List[Path]
        De-duplicated list of files (order preserved).

    Raises
    ------
    RuntimeError
        If an input path does not exist, or if a directory contains no matching files,
        or if no files are found overall.
    """
    files: List[Path] = []

    for a in inputs:
        p = Path(a)
        if p.is_file():
            files.append(p)
        elif p.is_dir():
            found = sorted(Path(x) for x in glob.glob(str(p / "trajectories_long_min*.csv")))
            # Fallback: some files might not have .csv extension
            if not found:
                found = sorted(Path(x) for x in glob.glob(str(p / "trajectories_long_min*")))
            if not found:
                raise RuntimeError(f"No trajectories_long_min* files found in directory: {p}")
            files.extend(found)
        else:
            raise RuntimeError(f"Input path not found: {p}")

    # De-duplicate while preserving order
    seen = set()
    uniq: List[Path] = []
    for f in files:
        if f not in seen:
            uniq.append(f)
            seen.add(f)

    if not uniq:
        raise RuntimeError("No input files found.")
    return uniq


def get_frequency_column(df: pd.DataFrame, srcfile: Path) -> pd.Series:
    """
    Return a linear-frequency series named "frequency".

    Logic
    -----
    - If the input table has a column 'freq', it is used directly (coerced to numeric).
    - Else if it has 'log_freq', it is interpreted as log10(freq) and converted as:
          frequency = 10 ** log_freq
    - Otherwise, an error is raised.

    Parameters
    ----------
    df : pd.DataFrame
        Input table.
    srcfile : Path
        Source file path, used for error messages.

    Returns
    -------
    pd.Series (float)
        Linear frequency values.

    Raises
    ------
    RuntimeError
        If neither 'freq' nor 'log_freq' exists.
    """
    if "freq" in df.columns:
        out = pd.to_numeric(df["freq"], errors="coerce")
    elif "log_freq" in df.columns:
        out = 10 ** pd.to_numeric(df["log_freq"], errors="coerce")
    else:
        raise RuntimeError(f"Missing 'freq' or 'log_freq' in {srcfile}")
    return out


def select_clones_present_all_times_within_freq(
    df: pd.DataFrame,
    target_norm: str,
    n_non_target: int,
    freq_min: Optional[float],
    freq_max: Optional[float],
) -> List[str]:
    """
    Select clonotypes to extract from a single file.

    Selection includes:
      - TARGET clonotype (if present at least once in this file)
      - Up to `n_non_target` NON-target clonotypes that satisfy BOTH:
          (1) Present in ALL time points of this file
          (2) Mean frequency in [freq_min, freq_max] if any bounds are provided

    Ranking
    -------
    Non-target candidates are ranked by mean frequency (descending), and the top
    `n_non_target` are selected.

    Parameters
    ----------
    df : pd.DataFrame
        Must contain at least: 'aaSeqCDR3_norm', 'time', 'frequency'
    target_norm : str
        Normalized target CDR3 sequence (uppercase + trimmed).
    n_non_target : int
        Number of non-target clonotypes to select.
    freq_min : Optional[float]
        Minimum mean frequency (linear) for non-target selection; None disables.
    freq_max : Optional[float]
        Maximum mean frequency (linear) for non-target selection; None disables.

    Returns
    -------
    List[str]
        List of selected aaSeqCDR3_norm values (target first if present).
        If the file has no valid time points, returns an empty list.
    """
    times = sorted(df["time"].dropna().unique().tolist())
    n_times = len(times)
    if n_times == 0:
        return []

    # Clones present in all time points
    nunique_time = df.groupby("aaSeqCDR3_norm")["time"].nunique()
    candidates = nunique_time[nunique_time == n_times].index.tolist()

    # Mean frequency per clone
    mean_freq = (
        df.groupby("aaSeqCDR3_norm")["frequency"]
        .mean()
        .rename("mean_freq")
        .reset_index()
    )

    cand_df = pd.DataFrame({"aaSeqCDR3_norm": candidates}).merge(
        mean_freq, on="aaSeqCDR3_norm", how="left"
    )
    cand_df["mean_freq"] = cand_df["mean_freq"].fillna(0.0)

    # Apply frequency interval filter (linear)
    if freq_min is not None:
        cand_df = cand_df[cand_df["mean_freq"] >= float(freq_min)]
    if freq_max is not None:
        cand_df = cand_df[cand_df["mean_freq"] <= float(freq_max)]

    # Sort by mean frequency (descending)
    cand_df = cand_df.sort_values("mean_freq", ascending=False)

    selected: List[str] = []

    # Include target if present at least once
    if (df["aaSeqCDR3_norm"] == target_norm).any():
        selected.append(target_norm)

    # Add non-targets
    for c in cand_df["aaSeqCDR3_norm"].tolist():
        if c == target_norm:
            continue
        selected.append(c)

        non_target_count = sum(1 for x in selected if x != target_norm)
        if non_target_count >= n_non_target:
            break

    return selected


def build_argparser() -> argparse.ArgumentParser:
    """
    Build the CLI argument parser.

    Returns
    -------
    argparse.ArgumentParser
        Parser configured with all options and help strings.
    """
    p = argparse.ArgumentParser(
        description=(
            "Extract and plot TARGET clonotype trajectories plus N NON-target clonotypes that are "
            "present in all time points, optionally filtered by a mean-frequency interval."
        )
    )
    p.add_argument(
        "--input", "-i",
        nargs="+",
        required=True,
        help=(
            "One or more input CSV files and/or directories. If a directory is provided, the script "
            "searches for files matching 'trajectories_long_min*.csv' inside it."
        ),
    )
    p.add_argument(
        "--outdir", "-o",
        required=True,
        help="Output directory (created if it does not exist).",
    )
    p.add_argument(
        "--target",
        default=DEFAULT_TARGET,
        help=f"Target aaSeqCDR3 sequence (default: {DEFAULT_TARGET}). Matching is case-insensitive.",
    )
    p.add_argument(
        "--n-non-target",
        type=int,
        default=50,
        help="Number of NON-target clonotypes to include per file (default: 50).",
    )
    p.add_argument(
        "--freq-min",
        type=float,
        default=None,
        help="Minimum mean frequency (linear) for selecting NON-target clones (optional).",
    )
    p.add_argument(
        "--freq-max",
        type=float,
        default=None,
        help="Maximum mean frequency (linear) for selecting NON-target clones (optional).",
    )
    p.add_argument(
        "--no-show",
        action="store_true",
        help="Do not open an interactive window with plt.show() (useful on servers).",
    )
    return p


def main() -> None:
    """
    Main entry point.

    Workflow
    --------
    1) Parse arguments
    2) Collect input files (files and/or directories)
    3) For each file:
         - read data
         - validate required columns
         - normalize sequences
         - coerce time to numeric
         - compute linear frequency
         - select target + N non-target clones
         - accumulate selected rows
    4) Concatenate all selected trajectories
    5) Build observability pivot table (clone,time) x min_k
    6) Write outputs and generate plot
    """
    args = build_argparser().parse_args()

    outdir = Path(args.outdir).expanduser().resolve()
    outdir.mkdir(parents=True, exist_ok=True)

    input_files = collect_input_files(args.input)

    print("Input files:")
    for f in input_files:
        print(" ", f)

    target_norm = args.target.strip().upper()

    all_rows = []
    selection_rows = []

    for f in input_files:
        min_k = extract_min_from_filename(f)

        # Auto-detect separator (CSV/TSV/etc.)
        df = pd.read_csv(f, sep=None, engine="python")
        df.columns = [c.strip() for c in df.columns]

        # Required columns
        for col in ["aaSeqCDR3", "time", "observable"]:
            if col not in df.columns:
                raise RuntimeError(f"Missing column '{col}' in {f}")

        # Normalize clonotype sequence & parse types
        df["aaSeqCDR3_norm"] = df["aaSeqCDR3"].astype(str).str.strip().str.upper()
        df["observable"] = as_bool_series(df["observable"])

        df["time"] = pd.to_numeric(df["time"], errors="coerce")
        if df["time"].isna().any():
            bad = df[df["time"].isna()].head(5)
            raise RuntimeError(
                f"Non-numeric 'time' values found in {f}. Example rows:\n{bad}"
            )

        df["frequency"] = get_frequency_column(df, f)

        # Select clones for this file
        selected_norm = select_clones_present_all_times_within_freq(
            df=df,
            target_norm=target_norm,
            n_non_target=args.n_non_target,
            freq_min=args.freq_min,
            freq_max=args.freq_max,
        )

        if not selected_norm:
            print(f"\n[WARNING] No valid time points found in {f} (min_k={min_k}). Skipping.")
            continue

        # Console summary
        times = sorted(df["time"].unique().tolist())
        n_times = len(times)
        present_all = df.groupby("aaSeqCDR3_norm")["time"].nunique().eq(n_times).sum()
        n_selected_non_target = sum(1 for x in selected_norm if x != target_norm)

        print(
            f"\n[file={f.name}] min_k={min_k} | time points={n_times} | clones present all times={present_all} | "
            f"selected non-target={n_selected_non_target} (requested={args.n_non_target})"
        )

        if not (df["aaSeqCDR3_norm"] == target_norm).any():
            print(f"  [WARNING] Target clonotype not found in: {f} (min_k={min_k})")

        # Record selection table rows
        for c in selected_norm:
            selection_rows.append(
                {
                    "min_k": min_k,
                    "source_file": f.name,
                    "aaSeqCDR3_norm": c,
                    "is_target": (c == target_norm),
                }
            )

        # Extract only selected trajectories
        df_sel = df[df["aaSeqCDR3_norm"].isin(selected_norm)].copy()
        df_sel["min_k"] = min_k
        df_sel["source_file"] = f.name

        # Keep a consistent column subset (include optional columns if present)
        keep_cols = []
        if "subject" in df_sel.columns:
            keep_cols.append("subject")
        keep_cols += ["source_file", "aaSeqCDR3", "aaSeqCDR3_norm", "time", "observable"]
        if "p_emp_low" in df_sel.columns:
            keep_cols.append("p_emp_low")
        keep_cols += ["frequency", "min_k"]

        all_rows.append(df_sel[keep_cols].copy())

    if not all_rows:
        raise RuntimeError("No data extracted from any input file.")

    traj = (
        pd.concat(all_rows, ignore_index=True)
        .sort_values(["min_k", "aaSeqCDR3_norm", "time"])
    )

    sel_df = (
        pd.DataFrame(selection_rows)
        .drop_duplicates()
        .sort_values(["min_k", "is_target"], ascending=[True, False])
    )

    # Observability matrix: index=(clone,time), columns=min_k, values=observable
    obs_table = (
        traj.pivot_table(
            index=["aaSeqCDR3_norm", "time"],
            columns="min_k",
            values="observable",
            aggfunc="max",
        )
        .fillna(False)
        .astype(bool)
    )

    # Output paths
    p_sel = outdir / "selected_clones_by_min_k.csv"
    p_traj = outdir / "multi_clones_extracted_trajectories.csv"
    p_obs = outdir / "multi_clones_observability_by_min_k.csv"
    p_png = outdir / "multi_clones_frequency_vs_time.png"

    # Write outputs
    sel_df.to_csv(p_sel, index=False)
    traj.to_csv(p_traj, index=False)
    obs_table.to_csv(p_obs, index=True)

    # Plot (explicit linear y-scale)
    plt.figure()
    for (min_k, clone), g in traj.groupby(["min_k", "aaSeqCDR3_norm"]):
        is_target = (clone == target_norm)
        plt.plot(
            g["time"],
            g["frequency"],
            marker="o",
            linewidth=2.5 if is_target else 1.0,
            alpha=1.0 if is_target else 0.25,
            label=(f"TARGET (min_k={min_k})" if is_target else None),
        )

    plt.xlabel("Simulated time point")
    plt.ylabel("Clonotype frequency (linear)")
    plt.yscale("linear")

    title = f"Target + {args.n_non_target} non-target (present all times)"
    if args.freq_min is not None or args.freq_max is not None:
        title += f" | mean_freq in [{args.freq_min},{args.freq_max}]"
    plt.title(title)

    handles, labels = plt.gca().get_legend_handles_labels()
    if handles:
        plt.legend()

    plt.tight_layout()
    plt.savefig(p_png, dpi=200)

    if not args.no_show:
        plt.show()
    plt.close()

    print("\nSaved outputs:")
    print(f" - {p_sel}")
    print(f" - {p_traj}")
    print(f" - {p_obs}")
    print(f" - {p_png}")


if __name__ == "__main__":
    main()
